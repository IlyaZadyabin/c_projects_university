Submit a solution for up12-1-ipc-1 (дореш)
Full score:	100
Run penalty:	10
Time limit:	2 s
Real time limit:	2 s
Memory limit:	64M
Stack limit:	8M
Open date:	2019/12/09 15:00:00
Date penalty formula:	2019/12/31 0-50/14d
Next soft deadline:	2019/12/23 15:00:00
Problem up12-1: ipc-1 (дореш)
Программе в аргументах командной строки задаются:

Количество процессов (nproc) (1 <= nproc <= 400);
Ключ IPC (key);
Максимальное значение (maxval) (32-битное знаковое целое положительное значение).
Программа должна создать nproc процессов и запустить между ними пересылку числа. Процессы нумеруются от 1 до nproc. Процесс-родитель имеет номер 0. Каждый процесс получает число, печатает свой порядковый номер, значение числа, и номер процесса-отправителя как показано в примере. Затем процесс увеличивает его на 1 и пересылает число процессу с номером (val * val * val * val) % nproc + 1, где val – значение числа после увеличения. Если значение числа после увеличения стало больше maxval, процесс не пересылает число следующему, а (совместно с родителем) выполняет действия по завершению игры. Игра начинается с первого из созданных процессов со значения 0. Отец дожидается завершения всех процессов и сам завершает работу.

Обратите внимание, при достижении максимального значения оно печатается, но не пересылается дальше.

Для синхронизации процессов используйте семафоры. Для пересылки значения используйте разделяемую память. Массив семафоров и разделяемая память должны уничтожаться в конце работы. Сигналы использовать запрещено.

Тестирование завершается с вердиктом 'Synchronization error', если процесс-отец (то есть ваша программа, запускаемая на тестирование) заканчивает работу раньше какого-либо из своих потомков.

Тестирование завершается с вердиктом 'Security violation', если после завершения работы вашей программы остались неудаленные объекты IPC.

Examples
Input
Output
1 0 0
2 1 1
1 2 2
2 3 1
1 4 2

Submit a solution for up12-2-ipc-2 (дореш)
Full score:	100
Run penalty:	10
Time limit:	1 s
Real time limit:	2 s
Memory limit:	64M
Stack limit:	8M
Open date:	2019/12/09 15:00:00
Date penalty formula:	2019/12/31 0-50/14d
Next soft deadline:	2019/12/23 15:00:00
Problem up12-2: ipc-2 (дореш)
Программе в аргументах командной строки задаются:

Размер массива (count);
Ключ IPC (key);
Количество процессов (nproc);
Число итераций (iter_count);
Затравка ГПСЧ для каждого процесса (nproc аргументов).
Программа должна создать в разделяемой памяти массив из count элементов типа int и заполнить его значениями, считанными со стандартного потока ввода.

Далее программа должна создать nproc процессов, для каждого процесса проинициализировав ГПСЧ соответствующим значением из командной строки.

Все процессы должны выполнить iter_count итераций модификации массива по следующему алгоритму. На каждой итерации выбираются два случайных индекса в массиве (каждый индекс в диапазоне [0;count) ) и случайное значение в диапазоне [0; 10). Далее должна вызываться функция operation, которая выполняет следующие действия:

void
operation(int *data, int ind1, int ind2, int value)
{
    if (ind1 != ind2) {
        int tmp1 = data[ind1] - value;
        int tmp2 = data[ind2] + value;

        data[ind1] = tmp1;
        data[ind2] = tmp2;
    }
}
Считайте эту функцию написанной и доступной в вашей программе.

Родитель дожидается окончания всех сыновей и выводит на стандартный поток вывода значения массива.

Для синхронизации процессов используйте семафоры. Для пересылки значения используйте разделяемую память. Массив семафоров и разделяемая память должны уничтожаться в конце работы.

Должна быть обеспечена целостность массива.

Синхронизация должна позволять двум процессам одновременно модифицировать массив, если модифицируемые индексы массива не пересекаются.


Submit a solution for up12-3-ipc-3 (дореш)
Full score:	100
Run penalty:	10
Time limit:	1 s
Real time limit:	2 s
Memory limit:	64M
Stack limit:	8M
Open date:	2019/12/09 15:00:00
Date penalty formula:	2019/12/31 0-50/14d
Next soft deadline:	2019/12/23 15:00:00
Problem up12-3: ipc-3 (дореш)
Программе задаются следующие аргументы командной строки:

Ключ IPC для очереди сообщений
Число процессов для запуска n
64-битное целое число value1
64-битное целое число value2
64-битное целое число maxval
Программа должна создать n процессов. Каждый процесс имеет свой номер от 0 до n - 1. Когда процесс получает очередь хода, с помощью очереди сообщений процесс должен получить два 64-битных целых числа x1, x2, вычислить их сумму x3 = x1 + x2, напечатать на стандартный поток вывода свой номер и число x3, затем переслать числа x2 и x3 процессу с номером x3 % n.

Гарантируется, что x3 всегда будет неотрицательным.

Если x3 по модулю больше значения maxval, то вместо пересылки следующему процессу все процессы должны завершиться.

В начале игры родительский процесс посылает процессу 0 числа value1 и value2.

Родительский процесс должен дождаться завершения работы всех процессов и сам завершиться.

Родительский процесс должен корректно обрабатывать ошибочное завершение fork(). При этом все уже созданные процессы должны быть уничтожены. Родитель должен завершиться с кодом 1.

Пример запуска программы:

../solution 1234 2 0 1 15
Результат работы:

0 1
1 2
0 3
1 5
1 8
0 13
1 21




Submit a solution for up12-4-ipc-4 (дореш)
Full score:	100
Run penalty:	10
Time limit:	1 s
Real time limit:	2 s
Memory limit:	64M
Stack limit:	8M
Open date:	2019/12/09 15:00:00
Date penalty formula:	2019/12/31 0-50/14d
Next soft deadline:	2019/12/23 15:00:00
Problem up12-4: ipc-4 (дореш)
В аргументах командной строки программе задается одно целое число count - число процессов-сыновей (1 ≤ count ≤ 100).

На стандартном потоке ввода подается последовательность 32-битных знаковых целых чисел в текстовом виде. Последовательность завершается признаком конца ввода.

Родитель создает count сыновей, которые нумеруются от 0 до count-1. Сыновья работают последовательно. В свою очередь каждый сын считывает одно число из входной последовательности, выводит на стандартный поток вывода свой номер и считанное число. Затем очередь работы передается сыну с номером, равным остатку (математическому) от деления считанного числа на количество процессов.

После создания всех процессов родитель передает очередь чтения процессу с номером 0. Затем родитель дожидается завершения работы сыновей и сам завершает работу.

Для синхронизации процессов используйте семафоры SysV IPC.

Идентификатор массива семафоров выбирайте самостоятельно. В конце работы программы все созданные объекты IPC должны быть уничтожены.

Стандартные потоки ввода и вывода являются каналами.

Ниже приведен пример работы при числе процессов 3.

Examples
Input
1 2 4 3 5 6 9 2
Output
0 1
1 2
2 4
1 3
0 5
2 6
0 9
0 2


Submit a solution for up12-5-ipc-5 (дореш)
Full score:	100
Run penalty:	10
Time limit:	1 s
Real time limit:	5 s
Memory limit:	64M
Stack limit:	8M
Open date:	2019/12/09 15:00:00
Date penalty formula:	2019/12/31 0-50/14d
Next soft deadline:	2019/12/23 15:00:00
Problem up12-5: ipc-5 (дореш)
В аргументах командной строки задаются имена текстовых файлов, содержащих неубывающие последовательности знаковых 32-битных целых чисел.

На стандартный поток вывода выведите неубывающую последовательность чисел, являющуюся пересечением входных последовательностей.

Например, если даны последовательности "1 2 2 3 3 3 4 4 4 4 5" и "2 3 3 4 5 5 5", то их пересечением будет последовательность "2 3 3 4 5", то есть если число встречается только в одной последовательности, оно не попадает в результат, а если число содержится в обеих последовательностях, то в результат попадает минимум количества этого числа в обеих последовательностях.

Вычисление результата организуйте с помощью параллельных процессов, причем каждый процесс находит пересечение ровно двух входных или промежуточных последовательностей. Организуйте работу процессов так, чтобы добится максимального параллелизма работы процессов.

Вы можете использовать любые средства межпроцессного взаимодействия.
