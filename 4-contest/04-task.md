Submit a solution for ht01-1-getline2
Time limit:	2 s
Real time limit:	5 s
Memory limit:	64M
Stack limit:	8M

Problem ht01-1: getline2
Написать функцию getline2, которая считывает строку текста (до символа \n) из заданного дескриптора потока.

char *getline2(FILE *f);
Функция считывает последовательность байтов неограниченной длины до символа ‘\n’ или до конца файла. В последовательности байтов не может встречаться байт ‘\0’. Функция возвращает указатель на строку (то есть завершающуюся байтом 0), выделенную в динамической памяти. В конце строки сохраняется байт ‘\n’, если он был считан из потока. Если из потока не был считан ни один байт но сразу был получен признак конца файла, функция getline должна вернуть NULL.

Используйте динамические массивы.

В случае ошибки выделения динамической памяти функция должна вернуть значение NULL.


Submit a solution for ht01-2-satsum
Time limit:	1 s
Real time limit:	5 s
Memory limit:	64M
Stack limit:	8M
Problem ht01-2: satsum
Напишите функцию

int32_t satsum(int32_t v1, int32_t v2);
которая выполняет сложение с насыщением двух знаковых чисел. То есть, если результат сложения не представим типом результата, результатом в зависимости от знака будет либо минимальное, либо максимальное число, представимое типом результата. Например, если складываются с насыщением два четырехбитных числа (диапазон представимых чисел [−8;7]): 5 + 5 => 7, −4 + −6 => −8.

Отрицательные числа представляются в дополнительном коде.

Функция должна быть максимально эффективной для ситуации, в которой при сложении двух чисел не возникает переполнения.

В функции не должны использоваться константы, значение которых зависит от размера типа uint32_t или int32_t (в частности, INT_MAX и аналогичные). В функции не должны использоваться конструкции, приводящие к Undefined Behavior.

Не используйте 64-битные типы. Не используйте вещественные операции. Можете использовать расширения компилятора GCC.


Submit a solution for ht01-3-uint-fit
Time limit:	1 s
Real time limit:	5 s
Memory limit:	64M
Stack limit:	8M
Problem ht01-3: uint-fit
На стандартном потоке ввода задается последовательность 32-битных беззнаковых целых чисел. Последовательность заканчивается с концом файла.

Для каждого введенного числа на отдельной строке напечатайте 1, если это число может быть точно представлено в виде значения типа `float`, и 0 в противном случае.

В решении не используйте операции с вещественными числами.

Операцию проверки точной представимости числа выделите в отдельную функцию.

Submit a solution for ht01-4-digit-freq
Time limit:	1 s
Real time limit:	5 s
Memory limit:	3M
Stack limit:	512K
Problem ht01-4: digit-freq
На стандартный поток ввода программе подается текстовый файл, который мог быть подготовлен как в Unix, так и в Windows. Первая строка текста этого файла содержит имя (путь) другого текстового файла, который требуется обработать. Последующие строки исходного текстового файла, если они присутствуют, должны игнорироваться.

Если файл существует и может быть прочитан, подсчитайте число вхождений каждого из символов десятичных цифр. Не существующий или нечитаемый файл полагайте пустым. Если стандартный поток ввода пуст, полагайте и обрабатываемый файл пустым.

Результат выведите в виде таблички:

<символ десятичной цифры> <число вхождений в файл этой цифры>
Не используйте глобальные переменные. От вашей программы требуется максимальная эффективность при обработке входных данных.

Пример ввода на стандартном потоке ввода:

input.txt
Это значит, что требуется обработать файл input.txt.

Пример вывода:

0 1
1 12312
2 3
3 0
4 0
5 0
6 0
7 0
8 0
9 0


Submit a solution for ht01-5-dectobin
Time limit:	1 s
Real time limit:	5 s
Memory limit:	64M
Stack limit:	8M
Problem ht01-5: dectobin
На стандартном потоке ввода вводится положительное целое число prec (не превышает 150000), затем, отделенная пробельными символами, дробная часть числа в десятичной записи. Длина дробной части числа не превышает 50000 десятичных знаков. Преобразуйте дробную часть числа в десятичной записи в дробную часть числа в двоичной записи с prec двоичными знаками. Округляйте к ближайшему четному.

При выводе дробной части числа разбейте его на группы по 32 бита, дополняя последнюю неполную группу справа нулевыми битами, и выводите каждую группу в шестнадцатеричной записи как показано на примере, разделяя группы пробелом. Если после округления к ближайшему четному число стало равно 1, выведите его, как показано в соответствующем примере.

Examples
Input
5 125
Output
20000000
Input
40 1
Output
19999999 9a000000
Input
1 25
Output
00000000
Input
1 75
Output
1 00000000
Input
8 99
Output
fd000000
Input
8 999
Output
1 00000000
